### 新生代与老生代

### Scavenge算法



```
新生代是记录新创建的内存的地方，采用空间换取时间的Scavenge算法，存在两个区域，一个使用中，另一个空闲。当FROM中耗尽的时候，将FROM（使用的）区中的新生成的正在使用的内存放入TO区，已经经历过一次交换的内存放到老区，释放FROM区。并且它的释放是广度优先的。



```



### Mark-Sweep算法

```
处理老生代对象时，采用深度优先扫描，用三色标记的算法。V8使用每个对象的两个mark-bits和一个标记工作栈来实现标记。

两个mark-bits编码三种颜色：白色（00），灰色（10）和黑色（11）。

白色表示对象可以回收，黑色表示对象不能回收，并且他的所有引用都被便利完毕了，灰色表示不可回收，他的引用对象没有扫描完毕。



```

```
从已知对象开始，即roots(全局对象和激活函数), 将所有非root对象标记置为白色

将root对象的所有直接引用对象入栈（marking worklist）

依次pop出对象，出栈的对象标记为黑，同时将他的直接引用对象标记为灰色并push入栈

栈空的时候，仍然为白色的对象可以回收

回收白色的对象

```



```
这个操作主要是为了防止释放全局变量，一开始gc回收都是进行计数

但是如果a引用b，b引用a，那么在函数退出的时候无法释放，所以采用这种方法，将不在全局中的全部释放。

```



### Mark-Compact算法



```
在对象标记死亡后，在整理的过程中，将活着的对象向另一个内存页移动，移动完后内存页就可以还给操作系统，但如果这一页的活动对象被很多其他页的对象引用，就不会compact，因为移动完后更新其他引用的指针开销大。
```



### 全暂停与增量标记

```
程序在回收垃圾的时候会发生卡顿，为了解决这个问题，把回收流程拆成多个小步骤。
```



```
增量标记和普通标记不同的是，对象的图谱关系可能发生变化！我们需要特别注意的是，那些从黑对象指向白对象的新指针。回忆一下，黑对象表示其已完全被垃圾回收器扫描，并不会再进行二次扫描。因此如果有“黑→白”这样的指针出现，我们就有可能将那个白对象漏掉，错当死对象处理掉。于是我们不得不再度启用写屏障。现在写屏障不仅记录“老→新”指针，同时还要记录“黑→白”指针。一旦发现这样的指针，黑对象会被重新染色为灰对象，重新放回到双端队列中。当算法将该对象取出时，其包含的指针会被重新扫描，这样活跃的白对象就不会漏掉。
```



### 写屏障（write barrier）



```
在介绍老生代的 GC 算法之前，我们还需要补充一个问题。由于我们想回收的是新生代的对象，只需要检查指向新生代的引用，那么在跟随根对象->新生代或者新生代->新生代的引用时，我们可以放心走下去。而对于新生代->老生代或者根对象->老生代的引用，如果选择跟随，扫遍了整个堆，花费的时间就划不来了。但是如果不沿着扫描，万一新生代里有对象只有从老生代过来的引用。所以在老生代指向新生代的时候维护一个列表记录这些东西。
```





